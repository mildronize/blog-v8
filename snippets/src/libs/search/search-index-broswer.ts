import FlexSearch from 'flexsearch';
import pAll from 'p-all';
import { ImportSearchIndexFromRemoteOptions, IndexSize, SearchIndexMetadataResponse } from './types';
import { ConsoleLogger } from '../../utils/logger';
import { createFlexSearchIndex, searchIndex } from './search-index';
import { RawSearchResult, SearchResult, serializeSearchResult } from './search-result';
import { MarkdownMetadata } from '../content/type';
import { joinUrl } from './browser-utils';

export type WorkerFunction<T = any> = () => Promise<T>;
/**
 * Simple function to `path.basename` from Node.js
 * @param path 
 * @returns 
 */
export function getBasename(path: string, extension: string): string {
  // Use regex or split to get the basename
  const basename = path.split('/').pop() || "";
  return basename.replace(extension, '');
}

export async function importSearchIndexFromRemote(options: ImportSearchIndexFromRemoteOptions): Promise<FlexSearch.Document<unknown, string[]>> {
  const { indexSize, logger = new ConsoleLogger(), hostname, concurrency = 6 } = options;
  const index = createFlexSearchIndex(indexSize, logger);
  const workers: WorkerFunction[] = [];

  for (const indexFile of options.indexFiles) {
    workers.push(async () => {
      const data = await (await fetch(joinUrl(hostname, indexFile))).json();
      const key = getBasename(indexFile, '.json');
      await index.import(key, data);
      logger.info(`Imported index key: ${key}, file: ${indexFile}`);
    });
  }
  await pAll(workers, { concurrency });
  return index;
}

const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

interface BroswerSearchOptions {
  /**
   * Search index metadata path e.g. /api/search-index-metadata.json
   * Typically, this file is generated by `executeBuildSearchIndex`
   * 
   * The index size depends on given metadata path
   */
  searchIndexMetadataPath: string;
  /**
   * Post metadata path e.g. /api/post-metadata.json
   */
  postMetadataPath: string;
  /**
   * Each time the search fails, it will wait for `waitTime` milliseconds before retrying
   * 
   * Default: 100;
   */
  waitTime?: number;

  /**
   * Hostname of the server, empty string for relative path
   */
  hostname?: string;
  indexSize: IndexSize;
}

export class BrowserSearch {
  private waitTime;
  isInitialized = false;
  index: FlexSearch.Document<unknown, string[]> | null = null;
  postMetadata: MarkdownMetadata[] | null = null;

  constructor(public options: BroswerSearchOptions) {
    this.waitTime = options.waitTime ?? 100;
  }

  async init() {
    if (this.isInitialized) {
      return;
    }
    this.isInitialized = true;
    const workers: [WorkerFunction<FlexSearch.Document<unknown, string[]>>, WorkerFunction<MarkdownMetadata[]>] = [
      async () => {
        const searchMetadata = await this.getSearchMetadata();
        return importSearchIndexFromRemote({
          ...this.options,
          indexFiles: searchMetadata.sitemap,
        });
      },
      async () => {
        return await (await fetch(joinUrl(this.options.hostname, this.options.postMetadataPath))).json();
      },
    ];
    const [index, postMetadata] = await pAll(workers);
    this.index = index;
    this.postMetadata = postMetadata;
  }

  async getSearchMetadata(): Promise<SearchIndexMetadataResponse> {
    return (await fetch(joinUrl(this.options.hostname, this.options.searchIndexMetadataPath))).json();
  }

  async search(query: string, retried = 100): Promise<SearchResult[]> {
    if (!this.isInitialized) {
      await this.init();
    }
    if (!this.index || !this.postMetadata) {
      if (retried > 0) {
        await delay(this.waitTime);
        return this.search(query, retried - 1);
      }
      throw new Error('Search index or post metadata is not initialized');
    }
    const searchResults = await searchIndex(this.index, query);
    return serializeSearchResult({
      rawResult: searchResults as RawSearchResult[],
      postMetadata: this.postMetadata,
      hostname: this.options.hostname,
      query,
    });
  }

  get isReady() {
    return this.isInitialized && !!this.index && !!this.postMetadata;
  }

}
