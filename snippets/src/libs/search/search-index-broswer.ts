import 'client-only';

import FlexSearch from 'flexsearch';
import { ImportSearchIndexFromRemoteOptions, IndexSize, SearchIndexMetadataResponse } from './types';
import { ConsoleLogger } from '../../utils/logger';
import { createFlexSearchIndex, searchIndex } from './search-index';
import { RawSearchResult, SearchResult, serializeSearchResult } from './search-result';
import { MarkdownMetadata } from '../content/type';
import { joinUrl } from './browser-utils';
/**
 * Simple function to `path.basename` from Node.js
 * @param path 
 * @returns 
 */
export function getBasename(path: string, extension: string): string {
  // Use regex or split to get the basename
  const basename = path.split('/').pop() || "";
  return basename.replace(extension, '');
}

export async function importSearchIndexFromRemote(options: ImportSearchIndexFromRemoteOptions): Promise<FlexSearch.Document<unknown, string[]>> {
  const { indexSize, logger = new ConsoleLogger(), hostname } = options;
  const index = createFlexSearchIndex(indexSize, logger);
  for (const indexFile of options.indexFiles) {
    const data = await (await fetch(joinUrl(hostname, indexFile))).json();
    const key = getBasename(indexFile, '.json');
    await index.import(key, data);
    logger.info(`Imported index key: ${key}, file: ${indexFile}`);
  }
  return index;
}

const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

interface BroswerSearchOptions {
  /**
   * Search index metadata path e.g. /api/search-index-metadata.json
   * Typically, this file is generated by `executeBuildSearchIndex`
   * 
   * The index size depends on given metadata path
   */
  searchIndexMetadataPath: string;
  /**
   * Post metadata path e.g. /api/post-metadata.json
   */
  postMetadataPath: string;
  /**
   * Each time the search fails, it will wait for `waitTime` milliseconds before retrying
   * 
   * Default: 100;
   */
  waitTime?: number;

  /**
   * Hostname of the server, empty string for relative path
   */
  hostname?: string;
  indexSize: IndexSize;
}

export class BrowserSearch {
  private waitTime;
  isInitialized = false;
  index: FlexSearch.Document<unknown, string[]> | null = null;
  postMetadata: MarkdownMetadata[] | null = null;

  constructor(public options: BroswerSearchOptions) {
    this.waitTime = options.waitTime ?? 100;
  }

  async init() {
    if (this.isInitialized) {
      return;
    }
    this.isInitialized = true;
    const searchMetadata = await this.getSearchMetadata();
    this.index = await importSearchIndexFromRemote({
      ...this.options,
      indexFiles: searchMetadata.sitemap,
    });
    this.postMetadata = await (await fetch(joinUrl(this.options.hostname, this.options.postMetadataPath))).json();
  }

  async getSearchMetadata(): Promise<SearchIndexMetadataResponse> {
    return (await fetch(joinUrl(this.options.hostname, this.options.searchIndexMetadataPath))).json();
  }

  async search(query: string, retried = 100): Promise<SearchResult[]> {
    if (!this.isInitialized) {
      await this.init();
    }
    if (!this.index || !this.postMetadata) {
      if (retried > 0) {
        await delay(this.waitTime);
        return this.search(query, retried - 1);
      }
      throw new Error('Search index or post metadata is not initialized');
    }
    const searchResults = await searchIndex(this.index, query);
    return serializeSearchResult({
      rawResult: searchResults as RawSearchResult[],
      postMetadata: this.postMetadata,
      hostname: this.options.hostname,
      query,
    });
  }

  get isReady() {
    return this.isInitialized && !!this.index && !!this.postMetadata;
  }

}
